расставлены скобки для обозначения порядка операций, задание я не переписывал.
a = (((b + (c * d))<< 2) & 8) //число b + c*d побитово сдвинули на 2 разряда влево (т.е. умножили на 4) и посмотрели на четвёртый бит слева, применив маску 0...000001000 (т.е. 8). В итоге числу a присвоится либо 8, либо 0, что и будет значением всего выражения.
(a & 077) |= 3 //некорректно, поскольку compound assignment может применяться только к переменной, но не к выражению.
(a == b) || ((a == c) && (c < 5)) //возвращает true, если a равно c и c меньше пяти или если a равно b
c = (x != 0) //c присваивается значение !!x или bool(x), возвращается оно же. 
(0 <= I) < 7 //возвращает всегда true, поскольку каким бы ни было значение 0<=I - единицей или нулём - это меньше семи
1,(2 + 3) //возвращает 5, поскольку запятая возвращает второй аргумент и имеет низший приоритет
a=-(1++)(b--)5 //некорректно - попытка увеличить значение переменной 1? потом сразу прямым текстом b-- без малейшего оператора между ними, а потом сразу 5, тоже без оператора между ними. Компилятор ругается на недостаток точек с запятыми, но они тоже не помогут, поскольку 1 не является переменной и к ней неприменим ++
a = - 1 + (+ b) - (- 5) //a присваивается  значение, на 4 меньшее, чем b, возвращается оно же.
a = (b == (c++)) //c увеличится на единицу, b сравнится с прежним значением c, a присвоится результат этого сравнения, всё выражение равно a.
a = (b = (c = 0)) //a,b,c присвоятся нулю, вернётся тоже ноль.
((a[4][2]) *=(* b) )? c : (*d)*2 //элемент двумерного массива умножается на значение, на которое указывает указатель b, если в результате получилось не ноль (такое может быть только если элемент ненулевой и b указывает на что-то ненулевое), возвращаем c, иначе - удвоенное значение, на которое указывает d.
(a - b), (c = d) //c присвоилось d, выражение a-b посчиталось в никуда, возвращается второй аргумент запятой, т.е. значение d, которое присвоилось c
*(p++) //увеличиваем указатель на единицу, делаем разыменование по старому значению (постфиксный ++ возвращает прежнее значение)
*(--p) //уменьшаем указатель на единицу, делаем разыменование по новому значению (префиксный возвращает новое значение)
++(++(a--)) //некорректно: наименьший приоритет у постфиксного --, но он возвращает не переменную, а значение, а ++\-- не применимы к значению, только к переменной
(-(++(++a)))-- //некорректно: унарный минус возвращает не переменную, а выражение, к которому не может быть применён постфиксный -- за скобками.
++(a--) //некорректно: аналогично, постфиксный -- возвращает значение, а не переменную, а к значению префиксный ++ неприменим.
(int*)(p->m) //приведение к типу указатель на int того, что лежит в p->m (т.е. в поле m структуры, указателем на которую является p). можно приводить инты к типу указатель на инт, типа было число 3, стал указатель 0x0003 (так, кстати, удобно быстро переводить числа в 16-ричную систему: 16 превращается в 0x10, скажем). или был указатель на строку, стал на инт
*(p.m) //разыменование указателя, являющегося полем m структуры p.
*(a[i]) //разыменование i-ого элемента массива указателей.
a, (b = b), a //b присваивается b, возвращается a - второй аргумент последней запятой